"-----------------------------------------------------------------------------"
" Fuzzy selecting files by continuously descending into directories
" and re-generating the lists.
"-----------------------------------------------------------------------------"
" Function used with input() to prevent tab expansion and literal tab insertion
function! NullList(...) abort
  return []
endfunction

" Generate list of files in directory
function! s:list_files(dir) abort
  " Include both hidden and non-hidden
  let paths = split(globpath(a:dir, '*'), "\n") + split(globpath(a:dir, '.?*'), "\n")
  let paths = map(paths, 'fnamemodify(v:val, '':t'')')
  call insert(paths, s:newfile, 0) " highest priority
  return paths
endfunction

" Tab drop plugin from: https://github.com/ohjames/tabdrop
" WARNING: For some reason :tab drop and even :<bufnr>wincmd w fails
" on monde so need to use the *tab jump* command instead!
function! s:tab_drop(file) abort
  let visible = {}
  let path = fnamemodify(a:file, ':p')
  let tabjump = 0
  for t in range(tabpagenr('$')) " iterate through each tab
    let tabnr = t + 1 " the tab number
    for b in tabpagebuflist(tabnr)
      if fnamemodify(bufname(b), ':p') == path
        exe 'normal! ' . tabnr . 'gt'
        return
      endif
    endfor
  endfor
  if bufname('%') ==# '' && &modified == 0
    " Fill this window
    exec 'edit ' . a:file
  else
    " Create new tab
    exec 'tabnew ' . a:file
  end
endfunction

" Check if user selection is directory, descend until user selects a file
let s:newfile = '[new file]' " dummy entry for requesting new file in current directory
function! fzf#open_continuous(...) abort
  let paths = []
  for pattern in a:000
    let pattern = substitute(pattern, '^\s*\(.\{-}\)\s*$', '\1', '')  " strip spaces
    call extend(paths, expand(pattern, 0, 1))
  endfor
  while empty(paths) || len(paths) == 1 && isdirectory(paths[0])
    " Format directory name
    let path = empty(paths) ? '.' : paths[0]
    let path = fnamemodify(path, ':p')
    let path = substitute(path, '/$', '', '')
    " Get user selection
    " Note: Start of old while isdirectory loop
    let prompt = substitute(path, '^' . expand('~'), '~', '')
    let items = fzf#run({
      \ 'source': s:list_files(path),
      \ 'options': "--multi --no-sort --prompt='" . prompt . "/'",
      \ 'down': '~30%'
      \ })
    " Build user selections into paths
    let paths = []
    for item in items
      if item == s:newfile
        let item = input(prompt . '/', '', 'customlist,NullList')
      endif
      if item ==# '..'  " fnamemodify :p does not expand the previous direcotry sign, so must do this instead
        call add(paths, fnamemodify(path, ':h'))  " head of current directory
      elseif !empty(item)
        call add(paths, path . '/' . item)
      endif
    endfor
  endwhile
  " Open file(s), or if it is already open just jump to that tab
  for path in paths
    if isdirectory(path)  " false for empty string
      echohl WarningMsg
      echom "Warning: Skipping directory '" . path . "'."
      echohl None
    elseif !empty(path)
      call s:tab_drop(path)
    endif
  endfor
endfunction

"-----------------------------------------------------------------------------"
" Fuzzy select currently open files
"-----------------------------------------------------------------------------"
" Function that generates lists of tabs and their numbers
function! s:tab_select_source() abort
  if !exists('g:tabline_bufignore')
    let g:tabline_bufignore = ['qf', 'vim-plug', 'help', 'diff', 'man', 'fugitive', 'nerdtree', 'tagbar', 'codi'] " filetypes considered 'helpers'
  endif
  let items = []
  for t in range(tabpagenr('$')) " iterate through each tab
    let tabnr = t + 1 " the tab number
    let buflist = tabpagebuflist(tabnr)
    for b in buflist " get the 'primary' panel in a tab, ignore 'helper' panels even if they are in focus
      if index(g:tabline_bufignore, getbufvar(b, '&ft')) == -1
        let bufnr = b " we choose this as our 'primary' file for tab name
        break
      elseif b == buflist[-1] " occurs if e.g. entire tab is a help window; exception, and indeed use it for tab title
        let bufnr = b
      endif
    endfor
    if tabnr == tabpagenr()
      continue
    endif
    let items += [tabnr . ': ' . fnamemodify(bufname(bufnr), '%:t')] " actual name
  endfor
  return items
endfunction

" Function that jumps to the tab number from a line generated by tabselect
function! s:tab_select_sink(item) abort
  exe 'normal! ' . split(a:item, ':')[0] . 'gt'
endfunction

" Tab selection
function! fzf#tab_select() abort
  call fzf#run({
    \ 'source': s:tab_select_source(),
    \ 'options': '--no-sort --prompt="Tab> "',
    \ 'sink': function('s:tab_select_sink'),
    \ 'down':'~50%'
    \ })
endfunction

"-----------------------------------------------------------------------------"
" Fuzzy move the tab
" Note: We display the tab names in case we want to group this file
" appropriately amongst similar open files.
"-----------------------------------------------------------------------------"
" Move current tab to the exact place of tab number N
function! s:tab_move_sink(nr) abort
  if type(a:nr) == 0
    let nr = a:nr
  else
    let parts = split(a:nr, ':')  " fzf selection
    let nr = str2nr(parts[0])
  endif
  if nr == tabpagenr() || nr == 0 || nr ==# ''
    return
  elseif nr > tabpagenr() && v:version[0] > 7
    exe 'tabmove ' . nr
  else
    exe 'tabmove ' . (nr - 1)
  endif
endfunction

" Move to selected tab
function! fzf#tab_move(...) abort
  if a:0
    call s:tab_move_sink(a:1)
  else
    call fzf#run({
      \ 'source': s:tab_select_source(),
      \ 'options': '--no-sort --prompt="Number> "',
      \ 'sink': function('s:tab_move_sink'),
      \ 'down': '~50%'
      \ })
  endif
endfunction
