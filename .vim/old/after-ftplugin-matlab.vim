" Vim filetype plugin file
" Language:	matlab
" Maintainer:	Fabrice Guy <fabrice.guy at gmail dot com>
" Last Changed: 2010 May 19
"
" ADDS items to buffer string variable b:match_words that was
" generated by $VIMRUNTIME/macros/matchit.vim

"SO, DON'T RELOAD SYNTAX FILE HERE; USING SYNTAX ON IN .VIMRC
"SHOULD ALREADY SEARCH FOR FILE IN .VIM/SYNTAX AND .VIM/AFTER/SYNTAX
"Initial stuff (mysterious to me)
"if exists("b:did_ftplugin")
"  echo "Plugin not loaded."
"  finish
"endif
"b:did_ftplugin tells Vim to NOT load the 'default' plugin from $VIMRUNTIME

""Mysterious
"let b:did_ftplugin = 1
"let s:save_cpo = &cpo
"set cpo-=C
"setlocal fo+=croql

"Tabs
setlocal tabstop=4
setlocal softtabstop=4
setlocal shiftwidth=4

"Overrides (original is weird)
highlight MatlabComma ctermfg=LightMagenta ctermbg=NONE
highlight MatlabSemicolon ctermfg=LightMagenta ctermbg=NONE

"----------------------------------------------------------------------------------------------------
"MATCHING PAIRS
"----------------------------------------------------------------------------------------------------
"Get matching pairs (note syntax is 'first matching expression:next matching expression')
let s:mydefs = 0
if exists("loaded_matchit") && !s:mydefs
  let s:conditionalEnd = '\([-+{\*\:(\/]\s*\)\@<!\<end\>\(\s*[-+}\:\*\/)]\)\@!'
  let b:match_words = '\<classdef\>\|\<methods\>\|\<events\>\|'.
        \ '\<properties\>\|\<if\>\|\<while\>\|\<for\>\|\<switch\>\|'.
        \ '\<try\>\|\<function\>:' . s:conditionalEnd
endif
if exists("loaded_matchit") && s:mydefs
  "END GROUP...
  "will detect comments and 'end' within e.g. array indexing.. the \(\) group
      "the whole previous stuff into "atom" for testing by \@, BRACKETS mean  
      ""any character specified inside the []", and final \s* means "followed
      "by ANY AMOUNT of whitespace" (this is different than "glob" meaning;
      "<char>* means 0-Inf occurrences of <char>);
  "the \@<! and \@! require NOT the preceding things. see below: 
      "\@<! is "zero-width preceding non-match" i.e. returns zero-width if
      "preceding atom does not match JUST BEFORE what follows,
      "\@! is "zero-width non-match" i.e. returns zero-width if preceding
      "atom does not match EXACTLY AT CURRENT POSITION);
      "has to do with reading left-to-right I think; the \@< tells Vim to
      "put the "zero-width" indicator AFTER the stuff that follows, which
      "has to occur at end of regexp
  "FAILED ATTEMPTS
  "let s:conditionalEnd = '\(%.*\|[\,-+{\*(\/]\s*\)'.'\@<!'.'\<end\>'.
  "     \ '\(\s*[\,-+}\*\/)]\)'.'\@!' "WITH COMMAS AND COMMENTS
  "let s:conditionalEnd = '\(%.*\|[-+{\*(\/]\s*\)'.'\@<!'.'\<end\>'.
  "     \ '\(\s*[-+}\*\/)]\)'.'\@!' "WITHOUT COMMAS, WITH COMMENTS
  "let s:conditionalEnda = '\(%.*\|[-+{\*(\/]\s*\)'.'\@<!'.'\<end\%[if]\>'.
  "     \ '\(\s*[-+}\*\/)]\)'.'\@!' "TRY WITH KEYWORDS AS PART OF WORD
  "let s:conditionalEndb = '\(%.*\|[-+{\*(\/]\s*\)'.'\@<!'.
  "     \ '\<end\(\%[for]\|\%[while]\)\>'.'\(\s*[-+}\*\/)]\)'.'\@!'
  "FANCY ATTEMPTS
  let s:noComment = '\(%.*\)\@<!' 
  let s:conditionalEnd = '\([-+{\*(\/]\s*\)'.'\@<!'.'\<end\>'.
        \ '\(\s*[-+}\*\/)]\)'.'\@!' 
  "OVERWRITES FOR SIMPLICITY
  let s:noComment = '' "NO COMMENT FILTER
  let s:conditionalEnd = '\<end\>'
  let b:match_words = 
        \ s:noComment.'\(\<for\>\|\<parfor\>\|\<while\>\)' .':'. 
            \ s:noComment.'\<continue\>' .':'. s:noComment.'\<break\>' .':'.
            \ s:conditionalEnd
        \ .','.
        \ s:noComment.'\<if\>' .':'. s:noComment.'\<elseif\>' .':'. 
            \ s:noComment.'\<else\>' .':'. s:conditionalEnd
        \ .','.
        \ s:noComment.'\<switch\>' .':'. s:noComment.'\<case\>' .':'. 
            \ s:noComment.'\<otherwise\>' .':'. s:conditionalEnd 
"        \.','.
"        \ s:noComment.'\<function\>' .':'. s:noComment.'\<return\>' .':'. 
"           \ s:conditionalEnd
"        \.','.
"        \ s:noComment.'\<classdef\>\|\<properties\>\|\<methods\>\|'.
"           \ '\<events\>\|\<enumeration\>' .':'. s:conditionalEnd 
  "SUPER WEIRD -- for the first group before comma, can effortlessly go
  "between all groups, while for the NEXT group, get paralyzed/stuck at 'end'!
  "whether it is for/end if/end etc., only one that works is what comes first.
  "s:conditionalEnd must be messing stuff up!
endif

"Final stuff (also mysterious to me)
setlocal suffixes+=.m
setlocal suffixes+=.asv
"Change the :browse e filter to primarily show M-files
if has("gui_win32") && !exists("b:browsefilter")
  let  b:browsefilter="M-files (*.m)\t*.m\n" .
        \ "All files (*.*)\t*.*\n"
endif
let b:undo_ftplugin = "setlocal suffixesadd< suffixes< "
      \ . "| unlet! b:browsefilter"
      \ . "| unlet! b:match_words"
"let &cpo = s:save_cpo

"----------------------------------------------------------------------------------------------------
"INDENTING
"----------------------------------------------------------------------------------------------------
"Escape if loaded
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1
let s:functionWithoutEndStatement = 0

setlocal indentexpr=GetMatlabIndent()
setlocal indentkeys=!,o,O=end,=case,=else,=elseif,=otherwise,=catch

" Only define the function once.
if exists("*GetMatlabIndent")
  finish
endif

function! s:IsMatlabContinuationLine(lnum)
  let continuationLine = 0
  if a:lnum > 0
    let pnbline = getline(prevnonblank(a:lnum))
    " if we have the line continuation operator (... at the end of a line or
    " ... followed by a comment) it may be a line continuation
    if pnbline =~ '\.\.\.\s*$' || pnbline =~ '\.\.\.\s*%.*$'
      let continuationLine = 1
      " but if the ... are part of a string or a comment, it is not a
      " continuation line
      let col = match(pnbline, '\.\.\.\s*$')
      if col == -1
	let col = match(pnbline, '\.\.\.\s*%.*$')
      endif
      if has('syntax_items')
	if synIDattr(synID(prevnonblank(a:lnum), col + 1, 1), "name") =~ "matlabString" ||
	      \ synIDattr(synID(prevnonblank(a:lnum), col + 1, 1), "name") =~ "matlabComment" 
	  let continuationLine = 0
	endif
      endif
    endif
  endif
  return continuationLine
endfunction

function GetMatlabIndent()
  " Find a non-blank line above the current line.
  let plnum = prevnonblank(v:lnum - 1)

  " If the previous line is a continuation line, get the beginning of the block to 
  " use the indent of that line
  if s:IsMatlabContinuationLine(plnum - 1)
    while s:IsMatlabContinuationLine(plnum - 1)
      let plnum = plnum - 1
    endwhile
  endif

  " At the start of the file use zero indent.
  if plnum == 0
    return 0
  endif

  let curind = indent(plnum)
  if s:IsMatlabContinuationLine(v:lnum - 1) 
    let curind = curind + &sw
  endif
  " Add a 'shiftwidth' after classdef, properties, switch, methods, events,
  " function, if, while, for, otherwise, case, try, catch, else, elseif
  if getline(plnum) =~ '^\s*\(classdef\|properties\|switch\|methods\|events\|function\|if\|while\|for\|otherwise\|case\|try\|catch\|else\|elseif\)\>'
    let curind = curind + &sw
    " In Matlab we have different kind of functions
    " - the main function (the function with the same name than the filename)
    " - the nested functions
    " - the functions defined in methods (for classes)
    " - subfunctions
    " Principles for the indentation :
    " - all the function keywords are indented (corresponding to the
    "   'indent all functions' in the Matlab Editor)
    " - if we have only subfonctions (ie if the main function doesn't have
    "   any mayching end), then each function is dedented
    if getline(plnum)  =~ '^\s*\function\>'
      let pplnum = plnum - 1
      while pplnum > 1 && (getline(pplnum) =~ '^\s*%')
	let pplnum = pplnum - 1
      endwhile
      " If it is the main function, determine if function has a matching end
      " or not
      if pplnum <= 1 
	" look for a matching end : 
	" - if we find a matching end everything is fine : end of functions
	"   will be dedented when 'end' is reached
	" - if not, then all other functions are subfunctions : 'function'
	"   keyword has to be dedended
	let old_lnum = v:lnum
	let motion = plnum . "gg"
	execute "normal" . motion
	normal %
	if getline(line('.')) =~ '^\s*end'
	  let s:functionWithoutEndStatement = 0
	else
	  let s:functionWithoutEndStatement = 1
	endif
	normal %
	let motion = old_lnum . "gg"
	execute "normal" . motion
      endif
    endif
    " if the for-end block (or while-end) is on the same line : dedent
    if getline(plnum)  =~ '\<end[,;]*\s*\(%.*\)\?$'
      let curind = curind - &sw 
    endif
  endif

  " Subtract a 'shiftwidth' on a else, elseif, end, catch, otherwise, case
  if getline(v:lnum) =~ '^\s*\(else\|elseif\|end\|catch\|otherwise\|case\)\>'
    let curind = curind - &sw
  endif
  " No indentation in a subfunction
  if getline(v:lnum)  =~ '^\s*\function\>' && s:functionWithoutEndStatement
    let curind = curind - &sw
  endif
  " First case after a switch : indent
  if getline(v:lnum) =~ '^\s*case'
    while plnum > 0 && (getline(plnum) =~ '^\s*%' || getline(plnum) =~ '^\s*$')
      let plnum = plnum - 1
    endwhile
    if getline(plnum) =~ '^\s*switch'
      let curind = indent(plnum) + &sw
    endif
  endif

  " end in a switch / end block : dedent twice
  " we use the matchit script to know if this end is the end of a switch block
  if exists("b:match_words")
    if getline(v:lnum) =~ '^\s*end'
      normal %
      if getline(line('.')) =~ '^\s*switch'
        let curind = curind - &sw
      endif
      normal %
    end
  end
  return curind
endfunction

" vim:sw=2
