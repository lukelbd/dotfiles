#!/usr/bin/env python
"""
Change the color of the highlight annotations in PDF document(s).
The destination color is hardcoded in this script.
"""
# Adapted from:
# https://unix.stackexchange.com/a/118492/112647
# PDF format reference:
# http://wwwimages.adobe.com/www.adobe.com/content/dam/Adobe/en/devnet/pdf/pdfs/PDF32000_2008.pdf
# pages 12 to 13 define the character sets
import pathlib
import re

# Color specification
PREFIX = b'/C ['
SUFFIX = b']'
COLOR = b'1.0 0.969 0.416'  # match PDF Expert highlight color on iPad
# COLOR b'254 245 142'  # this is what color dropper should show
# COLOR = b'0.0 0.0 0.0'

# Regular expressions
_to_char_group = lambda chars: '[' + re.escape(chars) + ']'
FLOAT = r'(?=\+|\-)?\d+(\.\d*)?'
WHITESPACE = '\x00\x09\x0A\x0C\x0D\x20'
DELIMITER = '()<>[]{}/%'
WS = _to_char_group(WHITESPACE)
DELIM = _to_char_group(DELIMITER)
SPECIAL = _to_char_group(WHITESPACE + DELIMITER)
REGEX_OBJ = re.compile(
    fr'(?<={SPECIAL})obj{WS}*<<.*?>>{WS}*endobj(?={SPECIAL})'.encode(), re.DOTALL
)
REGEX_ANNOT = re.compile(
    f'/Type{WS}*/Annot(?={SPECIAL})'.encode()
)
REGEX_HIGH = re.compile(
    f'/Subtype{WS}*/Highlight(?={SPECIAL})'.encode()
)
REGEX_COLOR = re.compile(
    fr'/C{WS}*\[{WS}*({FLOAT}){WS}+({FLOAT}){WS}+({FLOAT}){WS}*\]'.encode()
)


def process_color(match):
    """
    Replace colors in the input string.
    """
    diff = len(match.group(0)) - len(COLOR) - len(PREFIX) - len(SUFFIX)
    if diff < 0:
        raise NotImplementedError(
            'Replacement is too long and would require the size of the PDF '
            'file to change. This is not implemented.'
        )
    result = PREFIX + diff * b' ' + COLOR + SUFFIX
    return result


def process_obj(match):
    """
    Replace colors in the input text.
    """
    is_annot = REGEX_ANNOT.search(match.group(0))
    is_highlight = REGEX_HIGH.search(match.group(0))
    if is_annot and is_highlight:
        return REGEX_COLOR.sub(process_color, match.group(0))
    else:
        return match.group(0)


def process_file(path, dryrun=False, overwrite=False):
    """
    Replace colors in the input file and overwrite or create new file.
    """
    # Skip file
    name = path.name[:10] + '...'
    suffix = '_recolored'
    if path.suffix != '.pdf':
        print(f'File {name!r} is not a PDF.')
        return
    if suffix in path.name:
        print(f'File {name!r} was already fixed.')
        return
    # Repair data
    with open(path, 'rb') as f:
        old = f.read()
    try:
        new, count = REGEX_OBJ.subn(process_obj, old)
    except NotImplementedError:
        print(f'File {name!r} replacement failed.')
        return
    # Save results
    if count == 0:
        print(f'File {name!r} does not have highlighting.')
    elif dryrun:
        print(f'File {name!r} has highlighting.')
    else:
        if not overwrite:
            path = path.parent / (path.stem + suffix + '.pdf')
        print(f'Enforcing highlight color for file {name!r}')
        with open(path, 'wb') as f:
            f.write(new)


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description=__doc__, add_help=False)
    parser.add_argument(
        '-h',
        '--help',
        action='help',
        help='Show this help message and exit.'
    )
    parser.add_argument(
        '-d',
        '--dryrun',
        action='store_true',
        help='Print file names without editing them.'
    )
    parser.add_argument(
        '-o',
        '--overwrite',
        action='store_true',
        help=(
            'Overwrite the files instead of creating new ones with the suffix '
            "'_recolored.pdf'. Default behavior is the latter."
        )
    )
    parser.add_argument(
        'paths',
        nargs='*',
        type=str,
        help='PDF file(s) to process.'
    )
    args = parser.parse_args()

    for path in args.paths:
        path = pathlib.Path(path)
        process_file(path, dryrun=args.dryrun, overwrite=args.overwrite)
