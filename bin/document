#!/usr/bin/env bash
#------------------------------------------------------------------------------#
# May require bash 4.0
# This script compile LaTeX documents on macOS
# * Will compile a RTF version of document if filename is specially
#   formatted like manuscriptYYYY-MM-DD.tex
# * Will compile with a bibliography using any .bib file detected in
#   the same folder; useful because may want to keep the same .bib file
#   for every version of the manuscript. If you have more than one .bib file
#   the function will fail.
# * Why this instead of latexmk? It adds a few features, and also had issues with
#   latexmk where would always end up with random extra files being created. Only
#   way to consistently remove those temporary files was to query files present in
#   folder before/after compiling step; delete the new ones. This is better!
#------------------------------------------------------------------------------#
# Initial stuff
shopt -s nullglob # glob-expand into zero entries
latex=pdflatex # by default use pdflatex
bibtex=bibtex # for compiling bibliographies
templates="$HOME/latex" # location of LaTeX templates and style files
filename="$1" # the current file
htmlcompile="$2" # option
[ $TERM_PROGRAM = "Apple_Terminal" ] && terminal="Terminal" || terminal="$TERM_PROGRAM"
[ -z "$filename" ]    && echo "Error: Must call compile-script with filename."                                 && exit 1
[ -z "$htmlcompile" ] && echo "Error: Must call compile-script with true/false option for converting to docx." && exit 1
[ ! -r "$filename" ]  && echo "Error: File \"$filename\" does not exist."                                      && exit 1
if [[ "$filename" =~ / ]]; then # i.e. contains directory specifier
  directory="${filename%/*}" # trim shortest pattern matching <stuff>/*, keep "stuff"
  filename="${filename##*/}" # trim longest pattern matching */<stuff>, keep "stuff"
  [ ! -d "$directory" ] && echo "Error: Directory $directory does not exist." && exit 1
  cd "$directory" # move there
fi
filestem="${filename%.tex}" # simple
#------------------------------------------------------------------------------#
# Parse raw file to get some options
# First if GIF/animation in file, need to change from Skim to compatible viewer
cat "$filename" | grep -o '^[^%]*' | grep '\\animategraphics' &>/dev/null && viewer="Adobe Acrobat Reader DC" || viewer="Skim"
# Next detect if bibliography is present
cat "$filename" | grep -o '^[^%]*' | egrep '\\bibliography{.*}|\\printbibliography|\\nobibliography{.*}' &>/dev/null && bibliography=true || bibliography=false
# Finally detect if we want to run latexdiff on this file
[[ "$filename" =~ .*[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].tex ]] && dfilename="${filename%.tex}changes.tex" || dfilename="" # keep empty
# Special options for beamer
cat "$filename" | grep '\\documentclass\[.*\]{beamer}' &>/dev/null \
  && latex=pdflatex && dfilename="" && htmlcompile=false # beamer options
# Automatically choose from xelatex and pdflatex; just need xelatex for
# tex files that load fontspec, or use modules that themselves load fontspec
cat "$filename" | grep -o '^[^%]*' | egrep 'fontspec|xltxtra' &>/dev/null \
  && latex=xelatex && dfilename="" && htmlcompile=false

#------------------------------------------------------------------------------#
# Manage all LaTeX files, and move them around if necessary
#------------------------------------------------------------------------------#
# Function to remove massive number of auxiliary files generated by
# htlatex files and beamer files; extensions can be super weird so simply
# removing a list of extensions won't cut it; instead just detect new files
# Change ext_ignore to add exceptions to the deleted temporary files
function cleanup() {
  files_new=(*) # new files
  files_rm=() # record deleted
  ext_ignore=(tex bbl pdf docx png jpg jpeg eps gif)
  for file_new in "${files_new[@]}"; do
    if [[ ! " ${files_old[@]} " =~ " $file_new " ]]; then
      if [[ ! " ${ext_ignore[@]} " =~ " ${file_new##*.} " ]]; then
        echo "Removed file: $file_new."
        rm "$file_new" # delete the file
        files_rm+=("$file_new")
      fi
    fi
  done
}
# Function to find stuff
# * Supply with a list of latex-ish file names, then the extension as last argument
# * Important to call kpsewhich with a list of files rather than calling it
#   successively; otherwise can be extremely slow, for some strange reason
function latexfind() {
  [ $# -eq 1 ] && return 1
  ext=${!#} # the last argument
  names=($(echo ${@:1:$#-1} | tr " " "\n" | sort)) # the previous arguments 
  files=($(kpsewhich ${names[@]/%/.${ext}})) # append suffix to each file
  for name in ${names[@]}; do
    file="${name}.${ext}" # file we want
    # Potentially delete local file to 'refresh' things
    # [ -r "$1" ] && [ "$(realpath "$(pwd)")" != "$(realpath $templates)" ] \
    #   && rm "$1" # removes .sty or .bst file if not in template directory
    # Determine location and stuff
    if [[ ${files[@]} =~ $file ]]; then # search succeeded
      # if [ -e "./${file##*/}" ]; then
      if [[ " ${files[@]}" =~ " ./${name}.${ext}" ]]; then # is in cd
        echo "Using \"${file}\" from current directory."
      else
        echo "Using \"${file}\" from TeXLive distribution."
      fi
    else # search failed
      if [ -r "${templates}/${file}" ]; then
        echo "Copying \"${file}\" from latex directory to current directory."
        cp "${templates}/${file}" ./
      else
        echo "File \"${file}\" not found in latex directory or with kpsewhich."
        exit 1
      fi
    fi
  done
}

#------------------------------------------------------------------------------#
# Automatically detect packages and stuff
#------------------------------------------------------------------------------#
# First the custom .cls files
# Will ignore commented out lines; see https://unix.stackexchange.com/a/157607/112647
# Also ignore documentclass calls within verbatim commands; or just enforce starts at 0 position
class=($(cat "$filename" | grep -o '^[^%]*' | grep '^\\documentclass' |
          cut -s -d'{' -f2 | cut -s -d'}' -f1 ))
[ ${#class[@]} -gt 1 ] && echo "Error: Ambiguous document class: \"${class[@]}\"." && exit 1
echo "Finding class file..."
latexfind $class cls
# As above but for the RequirePackage lines in the .cls file
# * Have encountered a RequirePackage inside AtEndOfClass, so we also account for that
# * Also must delete stuff inside [] to account for possible nested {} argument
#   found there; see the regex from here: https://unix.stackexchange.com/a/14840/112647
# * Then we ignore lines with stray brackets; see https://stackoverflow.com/a/17050349/4970632
#   for how to do this with awk; for some reason sed wouldn't work, but gsed did work
# * Finally need to account for newcommand with RequirePackage inside it, which we
#   do by deleting lines containing a '#' character
# * Note this is *incomplete*, as it cannot handle multi-line requirepackage
#   commands which happens sometimes.
classfile=$(kpsewhich ${class}.cls)
[ -z $classfile ] && echo "Error: Could not find class file ${class}.cls" && exit 1
rpackages=($(cat "$classfile" | grep -o '^[^%]*' | grep '^.*\\RequirePackage' \
  | sed 's/\[[^][]*\]//g' | gsed '/\[\|\]/d' \
  | sed 's/AtEndOfClass{//g' | gsed '/newcommand\|#/d' \
  | cut -s -d'{' -f2 | cut -s -d'}' -f1 | tr ',' ' ' | xargs)) # | awk '!/\[|\]/'
echo "Finding sty dependencies of class..."
latexfind ${rpackages[@]} sty
# As above but for .sty files
# Will also detect \usepackage{package1,package2} lists
packages=($(cat "$filename" | grep -o '^[^%]*' |  egrep '^.*\\usepackage|^.*\\templatetype' \
  | sed 's/\[[^][]*\]//g' | gsed '/\[\|\]/d' \
  | sed 's/AtEndOfClass{//g' | gsed '/newcommand\|#/d' \
  | cut -s -d'{' -f2 | cut -s -d'}' -f1 | tr ',' ' ' | xargs))
echo "Finding preamble sty files..."
latexfind ${packages[@]} sty
# As above but for .bst file
bibstyle=($(cat "$filename" | grep -o '^[^%]*' \
  | grep '^.*\\bibliographystyle' \
  | cut -s -d'{' -f2 | cut -s -d'}' -f1))
if [ ${#bibstyle[@]} -eq 1 ]; then
  echo "Finding bst file..."
  latexfind $bibstyle bst
elif [ ${#bibstyle[@]} -gt 1 ]; then
  echo "More than one bibliographystyle found." && exit 1
fi

#------------------------------------------------------------------------------#
# Compile the document and display it
#------------------------------------------------------------------------------#
# Set the flags for compiling
# * Nonstop mode means no interaction, but keep trying to compile if encounter errors.
# * The shellescape option helps use eps figures that aren't in actual .tex directory.
#   See: https://www.scivision.co/pdflatex-error-epstopdf-output-filename-not-allowed-in-restricted-mode/
flags="-interaction=nonstopmode --shell-escape"
files_old=(*) # glob expansion to every filename
# Compile normal PDF, or the track-changes version
# * Always compile TWICE to enable glossary-references, equation-references
# * If bibliography present, compile once to get .aux file, run bibtex
#   on the auxfile (cannot call bibtex <file>.tex; must be bibtex <file> or
#   bibtex <file>.aux), then run TWICE as before.
# * See this page for matching consecutive lines with SED:
#   https://unix.stackexchange.com/q/165362/112647
echo "Compiling with $latex."
if $bibliography; then
  echo "Generating aux file..."
  $latex -draftmode $flags "$filestem" &>/dev/null
  echo "Generating bibliography..."
  $bibtex "$filestem" #&>/dev/null
fi
echo "Initial pass..."
$latex -draftmode $flags "$filestem" &>/dev/null
# $latex $flags "$filestem" 2>&1 | less # simple, use for debuggin
echo "Final pass..."
$latex $flags "$filestem" | sed -E '/^! |^l\./!d' | sed $'s/^! /\\\n/g' \
  | grep -A2 '^$' | sed '/^$/d' # the last line matches only triplets created
  # by the second sed line (blank\nmessage\nline#) and inserts '--' between groups of matches
  # sed -E uses extended regular expressions, not basic; allows or operator, like egrep
if [ ! -r "$filestem.pdf" ]; then
  echo "Error: PDF not produced." && cleanup
  exit 1
fi

#------------------------------------------------------------------------------#
# Create the difference-LaTeX file, with track changes
#------------------------------------------------------------------------------#
if [ ! -z "$dfilename" ] && [[ ! "$dfilename" =~ meeting ]]; then
  echo "The filename contains a date string. Will run latexdiff on the previous version."
  # Check for earlier version
  prefix=${filename%[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].tex} # parameter expensions are fire yo
  pfiles=($prefix[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].tex) # sorted manuscript files (glob is sorted by default)
  for index in "${!pfiles[@]}"; do
    # Get the part of list corresponding to files that
    # come BEFORE current one in alphanumeric sorting
    [ "${pfiles[$index]}" == "$filename" ] && break
  done
  # Create difference file if earlier version exists
  if [ "$index" -eq 0 ]; then echo "Warning: Cannot find previous version of this file."
  else # Tests index just before we broke from loop
    # Create difference texfile
    pfilename="${pfiles[$(($index - 1))]}" # previous index
    echo "Typesetting difference-PDF from $filename minus $pfilename..." # message
    [ -e "$dfilename" ] && rm "$dfilename"
    latexdiff "$pfilename" "$filename" > "$dfilename"
    if [ ! -r $dfilename ]; then
      echo "Error: Difference file not produed." && cleanup
      exit 1
    fi
    # Compile difference
    dfilestem="${dfilename%.tex}"
    if $bibliography; then
      echo "Preparing bibliography..."
      $latex -draftmode $flags "$dfilestem" &>/dev/null
      $bibtex "$dfilestem" #&>/dev/null
    fi
    echo "Typesetting PDF from $filename..."
    $latex -draftmode $flags "$dfilestem" &>/dev/null
    $latex $flags "$dfilestem" | sed -E '/^! |^l\./!d' | sed $'s/^! /\\\n/g' | tail +2
    if [ ! -r "$dfilestem.pdf" ]; then
      echo "Error: Difference PDF not produced." && cleanup
      exit 1
    fi
  fi
fi

#------------------------------------------------------------------------------#
# Get docx file that is readable in Word and Pages
#------------------------------------------------------------------------------#
if $htmlcompile; then
  if ! type htlatex &>/dev/null; then
    echo "Warning: HTLaTeX not found."
  elif ! type pandoc &>/dev/null; then
    echo "Warning: Pandoc not found, please install it with Homebrew."
  else
    # First get HTML file
    # Will filter most messages so more pallatable, only preserve errors and warnings
    echo "Creating HTML file with htlatex."
    htlatex "$filename" | sed -E '/^! |^l\./!d' | sed $'s/^! /\\\n/g' | tail +2
    if [ ! -r "$filestem.html" ]; then
      echo "Error: Conversion to HTML failed." && cleanup
      exit 1
    fi
    # Next change encoding to utf-8; can do it with vim
    # See: https://stackoverflow.com/a/23235290/4970632
    # vim -c "set fileencoding=utf-8 | wq" "$filestem.html"
    # Instead do it with iconv, which should come with most UNIX distros and conda
    # See: https://tex.stackexchange.com/a/200182/73149
    # Have to specify ASCII (the ISO string) manually for some reason, or it fails
    echo "Translating HTML file to UTF-8."
    iconv -f ISO-8859-1 -t UTF-8 "$filestem.html" > "tmp.html" && mv tmp.html "$filestem.html"
    # Finally convert to docx with pandoc; this will keep figures!
    # * Note that converting to a .doc extension will just leave the HTML, because
    #   pure HTML technically is compatible with the .doc extensions specs.
    # * If you browse the docx file with vim, will show message that we are browsing
    #   a 'zipfile', and you can descend into different sections.
    echo "Converting HTML to .docx with pandoc, so can be read in Word and Pages."
    pandoc -s "$filestem.html" -o "$filestem.docx"
  fi
fi

#------------------------------------------------------------------------------#
# Clean things up and open the appropriate apps
#------------------------------------------------------------------------------#
cleanup
open -a "$viewer" "$filestem.pdf" # open new pdf
[ ! -z "$dfilestem" ] && open -a "$viewer" "$dfilestem.pdf" # open difference
[ -e "$filestem.docx" ] && open -a "pages" "$filestem.docx" # open document
open -a $terminal # bring terminal back into focus

