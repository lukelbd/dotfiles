#!/usr/bin/env bash
#------------------------------------------------------------------------------#
# May require bash 4.0
# This script compile LaTeX documents on macOS. Why do we usually need
# 4 compilation steps?
#   1. At the first `latex` run, all `\cite{...}` arguments are written in the
#      file `document.aux`.
#   2. At the `bibtex` run, this information is taken by bibtex and the relevant
#      entries are put into the `.bbl` file, sorted either alphabetically or by
#      citation order (sometimes called "unsorted") and formatted according to
#      the instructions provided by the bibliography style that's in use.
#   3. At the next run of `latex`, the `.bbl` file is included at the point
#      the `\bibliography` instructions, and the correct labels for `\cite{...}`
#      commands are written in `.aux` file.
#   4. Only at the last run, `latex` knows what the correct labels are and
#      includes them in the document.
# Why this instead of latexmk? It adds a few features, and also had issues with
# latexmk where would always end up with random extra files being created. Only
# way to consistently remove those temporary files was to query files present in
# folder before/after compiling step; delete the new ones. This is better!
#------------------------------------------------------------------------------#
# Initial stuff
shopt -s nullglob # glob-expand into zero entries
latex=pdflatex    # by default use pdflatex
bibtex=bibtex     # for compiling bibliographies
filename="$1"     # the current file
texdiff="$2"      # get difference pdf?
tex2docx="$3"     # option
templates="$HOME/latex $HOME/latex2" # location of LaTeX templates and style files
[ "$TERM_PROGRAM" == "Apple_Terminal" ] && terminal="Terminal" || terminal="$TERM_PROGRAM"
[ -z "$terminal" ] && terminal="MacVim" # probably means we are running from GUI program
[ $# -ne 3 ] && echo "Error: Script requires exactly 3 arguments"
[ ! -r "$filename" ] && echo "Error: File \"$filename\" does not exist" && exit 1
! type gsed &>/dev/null && echo "Error: Need gsed installed. Use brew install coreutils"
if [[ "$filename" =~ / ]]; then # i.e. contains directory specifier
  directory="${filename%/*}"    # trim shortest pattern matching <stuff>/*, keep "stuff"
  filename="${filename##*/}"    # trim longest pattern matching */<stuff>, keep "stuff"
  [ ! -d "$directory" ] && echo "Error: Directory $directory does not exist" && exit 1
  cd "$directory" # move there
fi
filestem="${filename%.tex}" # simple
#------------------------------------------------------------------------------#
# Parse raw file to get some options
# Function for ignoring comments
function nocomments() { cat "$1" | grep -o '^[^%]*'; }

# Function for getting content inside braces
function inbraces() { cut -s -d'{' -f2 | cut -s -d'}' -f1 | tr ',' ' '; }

# First if GIF/animation in file, need to change from Skim to compatible viewer
nocomments "$filename" | grep '\\animategraphics' &>/dev/null \
  && viewer="Adobe Acrobat Reader DC" || viewer="Skim"

# Get actual .bib file or resource; will need it for
# The -n flag prevents printing every single line after running command
# nocomments "$filename" | egrep '\\bibliography{.*}|\\printbibliography|\\nobibliography{.*}' &>/dev/null \
#   && bibliography=true || bibliography=false
bibfile=$(nocomments "$filename" | gsed -n 's/^.*\\\(bibliography\|nobibliography\|addbibresource\){\(.*\)}.*$/\2/p')
if [ -z "$bibfile" ]; then
  bibliography=false
else
  bibliography=true
  bibfile="${bibfile%.bib}.bib" # add back extension, if abscent
  echo "Bibliography: \"$bibfile\""
fi

# Detect if we want to run latexdiff on this file
[[ "$filename" =~ .*[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].tex ]]
[ $? -eq 0 ] && dfilename="${filename%.tex}changes.tex" || dfilename=""

# Automatically choose from xelatex and pdflatex; just need xelatex for
# tex files that load fontspec, or use modules that themselves load fontspec
nocomments "$filename" | egrep 'fontspec|xltxtra' &>/dev/null
[ $? -eq 0 ] && latex=xelatex

# Use Lua if beamer present, will be faster
# Also required for beamerposter, not sure about other cases
nocomments "$filename" | grep 'documentclass.*{beamer}' &>/dev/null
[ $? -eq 0 ] && latex=lualatex

# Override if special package present
# Actually this caused everything to hang
# nocomments "$filename" | grep 'beamerposter' &>/dev/null
# [ $? -eq 0 ] && latex=lualatex # gemini recommends this at least

#------------------------------------------------------------------------------#
# Manage all LaTeX files, and move them around if necessary
#------------------------------------------------------------------------------#
# Function to remove massive number of auxiliary files generated by
# htlatex files and beamer files; extensions can be super weird so simply
# removing a list of extensions won't cut it; instead just detect new files
# Change ext_ignore to add exceptions to the deleted temporary files
function cleanup() {
  files_new=(*) # new files
  files_rm=() # record deleted
  ext_ignore=(tex bbl pdf docx png jpg jpeg eps gif)
  message="Removed files:\n"
  for file_new in "${files_new[@]}"; do
    if [[ ! " ${files_old[@]} " =~ " $file_new " ]]; then
      if [[ ! " ${ext_ignore[@]} " =~ " ${file_new##*.} " ]]; then
        message+="$file_new\n"
        rm "$file_new" # delete the file
        files_rm+=("$file_new")
      fi
    fi
  done
  printf "$message"
}

# Function to find stuff
# * Supply with a list of latex-ish file names, then the extension as last argument
# * Important to call kpsewhich with a list of files rather than calling it
#   successively; otherwise can be extremely slow, for some strange reason
function latexfind() {
  [ $# -eq 1 ] && return 1
  ext=${!#}                                        # last argument
  names=($(echo ${@:1:$#-1} | tr " " "\n" | sort)) # the previous arguments, sorted alphabetically
  files=($(kpsewhich ${names[@]/%/.${ext}}))       # append suffix to each file
  message=""
  for name in ${names[@]}; do
    file="${name}.${ext}" # file we want
    # [[ "${files[@]}" =~ "$file" ]] && echo 'true1'
    # ! [[ "${files[@]}" =~ " ./${file}" ]] && echo 'false2'
    if [[ "${files[@]}" =~ "$file" ]] && ! [[ " ${files[@]}" =~ " ./${file}" ]]; then
      # TeX distribution sees file, and it's not in current directory
      # message+="${file}:\tcurrent directory"
      message+="${file}:\tTeXLive distribution"
    else
      # Look for file in custom paths, copy over
      trigger=true; for template in $templates; do
        if [ -r "${template}/${file}" ]; then
          message+="${file}: copied to current directory (!!!)" # make more visible
          cp "${template}/${file}" ./
          trigger=false; break
        fi
      done
      $trigger && echo "${file} not found" && exit 1
    fi
    message+="\n"
  done
  column -t -s $'\t' <<< $(printf "$message") # weirdly piping doesn't work, only this works
}

#------------------------------------------------------------------------------#
# Automatically detect packages and stuff
#------------------------------------------------------------------------------#
# First the custom .cls files
# Will ignore commented out lines; see https://unix.stackexchange.com/a/157607/112647
# Also ignore documentclass calls within verbatim commands; or just enforce starts at 0 position
classes=($(nocomments "$filename" | grep '^\\documentclass' | inbraces))
          # cut -s -d'{' -f2 | cut -s -d'}' -f1 ))
[ ${#classes[@]} -gt 1 ] && echo "Error: Ambiguous document class: \"${classes[@]}\"." && exit 1
echo "Finding class file"
latexfind $classes cls

# As above but for the RequirePackage lines in the .cls file
# * Have encountered a RequirePackage inside AtEndOfClass, so we also account for that
# * Also must delete stuff inside [] to account for possible nested {} argument
#   found there; see the regex from here: https://unix.stackexchange.com/a/14840/112647
# * Then we ignore lines with stray brackets; see https://stackoverflow.com/a/17050349/4970632
#   for how to do this with awk; for some reason sed wouldn't work, but gsed did work
# * Finally need to account for newcommand with RequirePackage inside it, which we
#   do by deleting lines containing a '#' character
# * Note this is *incomplete*, as it cannot handle multi-line requirepackage
#   commands which happens sometimes.
classfile=$(kpsewhich ${classes}.cls)
[ -z $classfile ] && echo "Error: You should never see this error, already checked for ${classes}.cls existence, check code" && exit 1
rpackages=($(nocomments "$classfile" | grep '^.*\\RequirePackage' \
  | sed 's/\[[^][]*\]//g' | gsed '/\[\|\]/d' \
  | sed 's/AtEndOfClass{//g' | gsed '/newcommand\|#/d' \
  | inbraces))
  # | cut -s -d'{' -f2 | cut -s -d'}' -f1 | tr ',' ' ' | xargs)) # | awk '!/\[|\]/'
echo "Finding sty dependencies of class"
latexfind ${rpackages[@]} sty

# As above but for .sty files
# Will also detect \usepackage{package1,package2} lists
packages=($(nocomments "$filename" |  egrep '^.*\\usepackage|^.*\\templatetype' \
  | sed 's/\[[^][]*\]//g' | gsed '/\[\|\]/d' \
  | sed 's/AtEndOfClass{//g' | gsed '/newcommand\|#/d' \
  | inbraces))
  # | cut -s -d'{' -f2 | cut -s -d'}' -f1 | tr ',' ' ' | xargs))
echo "Finding preamble sty files"
latexfind ${packages[@]} sty

# As above but for .bst file
bibstyle=($(nocomments "$filename" | grep '^.*\\bibliographystyle' | inbraces))
  # | cut -s -d'{' -f2 | cut -s -d'}' -f1))
# if [ ${#bibstyle[@]} -eq 1 ]; then
echo "Finding bst file"
latexfind $bibstyle bst
# elif [ ${#bibstyle[@]} -gt 1 ]; then
#   echo "Error: More than one bibliographystyle found" && exit 1
# fi

# Next beamer theme
themes=($(nocomments "$filename" | grep '^.*\\usetheme' | inbraces | sed 's/^/beamertheme/'))
# latexfind ${themes[@]}
# if [ ${#themes[@]} -eq 1 ]; then
echo "Finding beamer theme file"
latexfind $themes sty
# elif [ ${#themes[@]} -gt 1 ]; then
#   echo "Error: More than one beamer theme found" && exit 1
# fi

# And beamer color theme
colorthemes=($(nocomments "$filename" | grep '^.*\\usecolortheme' | inbraces | sed 's/^/beamercolortheme/'))
# if [ ${#colorthemes[@]} -eq 1 ]; then
  echo "Finding beamer theme file"
  latexfind $colorthemes sty
# elif [ ${#colorthemes[@]} -gt 1 ]; then
#   echo "Error: More than one beamer colortheme found" && exit 1
# fi

#------------------------------------------------------------------------------#
# Compile the document and display it
#------------------------------------------------------------------------------#
# Set the flags for compiling
# * Nonstop mode means no interaction, but keep trying to compile if encounter errors.
# * The shellescape option helps use eps figures that aren't in actual .tex directory.
#   See: https://www.scivision.co/pdflatex-error-epstopdf-output-filename-not-allowed-in-restricted-mode/
flags="-interaction=nonstopmode --shell-escape"
files_old=(*) # glob expansion to every filename
# Compile normal PDF, or the track-changes version
# * Always compile *twice* to enable glossary-references, equation-references
# * If bibliography present, compile once to get .aux file, run bibtex
#   on the auxfile (cannot call bibtex <file>.tex; must be bibtex <file> or
#   bibtex <file>.aux), then run TWICE as before.
# * See this page for matching consecutive lines with SED:
#   https://unix.stackexchange.com/q/165362/112647
case $latex in
  xelatex)  stylized=XeLaTeX ;;
  pdflatex) stylized=PDFLaTeX ;;
  lualatex) stylized=LuaLaTeX ;;
  *) echo "Error: Unknown compiler \"$latex\"." && exit 1 ;;
esac
echo "Running with $stylized"
echo "Generating aux file" # maybe just need to generate glossary!
$latex -draftmode $flags "$filestem" &>/dev/null
if $bibliography; then
  echo "Generating bibliography"
  $bibtex "$filestem" #&>/dev/null
  echo "Incorporating bbl file"
  $latex -draftmode $flags "$filestem" &>/dev/null
fi
# This time want to read error messages
# * Below, the last line matches only triplets created by the second sed line
#   (blank\nmessage\nline#) and inserts '--' between groups of matches.
# * Also, sed -E uses extended regular expressions, not basic; allows |
#   operator, like egrep.
echo "Final pass"
$latex $flags "$filestem" | sed -E '/^! |^l\./!d' | sed $'s/^! /\\\n/g' \
  | grep -A2 '^$' | sed '/^$/d'
[ ! -r "$filestem.pdf" ] && echo "Error: PDF not produced" && cleanup

#------------------------------------------------------------------------------#
# Create the difference-LaTeX file, with track changes
#------------------------------------------------------------------------------#
if $texdiff && [ ! -z "$dfilename" ]; then
  # Check for earlier version
  prefix=${filename%[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].tex} # parameter expensions are fire yo
  pfiles=($prefix[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].tex) # sorted manuscript files (glob is sorted by default)
  # Get the part of list corresponding to files that
  # come BEFORE current one in alphanumeric sorting
  for index in "${!pfiles[@]}"; do
    [ "${pfiles[$index]}" == "$filename" ] && break
  done
  if [ "$index" -ne 0 ]; then
    # Get difference PDF, with changes highlighted
    pfilename="${pfiles[$(($index-1))]}"
    echo "Running latexdiff on ${filename##*/} minus ${pfilename##*/}"
    [ -e "$dfilename" ] && rm "$dfilename"
    latexdiff "$pfilename" "$filename" > "$dfilename"
    if [ ! -r $dfilename ]; then
      echo "Warning: Difference file not produced" && texdiff=false
    else
      # Finish the the pdflatex calls necessary to generate tables of contents, bibligrapyy, etc.
      dfilestem="${dfilename%.tex}"
      if $bibliography; then
        $latex -draftmode $flags "$dfilestem" &>/dev/null
        $bibtex "$dfilestem" #&>/dev/null
      fi
      $latex -draftmode $flags "$dfilestem" &>/dev/null
      $latex $flags "$dfilestem" | sed -E '/^! |^l\./!d' | sed $'s/^! /\\\n/g' | tail +2
      [ ! -r "$dfilestem.pdf" ] && echo "Warning: Difference PDF not produced" && texdiff=false
    fi
  fi
elif $texdiff; then
  echo "Warning: Previous version not found"
  texdiff=false
fi

#------------------------------------------------------------------------------#
# Convert to docx with pandoc; this will keep figures and format titles and
# sections with Word styling
#------------------------------------------------------------------------------#
if $tex2docx; then
  if ! type pandoc &>/dev/null; then
    echo "Warning: Pandoc not found. Use brew install pandoc"
  else
    echo "Running pandoc to convert tex-->docx"
    $bibliography && panbib="--bibliography=$bibfile" || panbib=""
    echo pandoc --output="$filestem.docx" "$panbib" "$filename"
    pandoc --output="$filestem.docx" "$panbib" "$filename"
  fi
fi

#------------------------------------------------------------------------------#
# Clean things up and open the appropriate apps
#------------------------------------------------------------------------------#
echo "Opening files"
cleanup
{ ! $texdiff && ! $tex2docx; } && open -a "$viewer" "$filestem.pdf" # open new pdf
$texdiff  && [ -e "$dfilestem.pdf" ] && open -a "$viewer" "$dfilestem.pdf" # open difference
$tex2docx && [ -e "$filestem.docx" ] && open -a "pages" "$filestem.docx" # open document
open -a $terminal # bring terminal back into focus

